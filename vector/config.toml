[cache]
  type = "file"
  basepath = "cache"

[[providers]]
  name = "osm2pgsql"
  type = "postgis"
  host = "/var/run/postgresql" # Default for Debian-based distributions
  port = 5432                     # postgis database port
  database = "gis"        # postgis database name
  user = ""
  password = ""

[[providers.layers]]
  name = "ne_water"
  geometry_fieldname = "way"
  geometry_type = "Polygon"
  sql = """
  SELECT
      ST_AsBinary(way) AS way
  FROM ne_ocean
  WHERE way && !BBOX!
  UNION ALL
  SELECT
      ST_AsBinary(way) AS way
  FROM ne_lake
  WHERE way && !BBOX!
  """

[[providers.layers]]
  name = "lz_water"
  geometry_fieldname = "way"
  geometry_type = "Polygon"
  sql = """
  SELECT
      ST_AsBinary(ST_SimplifyPreserveTopology(way, pixel_size(!ZOOM!)*.25)) AS way,
      NULL as osm_id
    FROM simplified_ocean_polygons
    WHERE way && !BBOX!
  UNION ALL
  SELECT
      ST_AsBinary(ST_SimplifyPreserveTopology(way, pixel_size(!ZOOM!)*.25)) AS way,
      osm_id
    FROM planet_osm_polygon
    WHERE way && !BBOX!
      AND (waterway = 'riverbank'
        OR landuse = 'reservoir'
        OR "natural" = 'water')
      AND way_area > pixel_area(!ZOOM!)*0.25
  """
[[providers.layers]]
  name = "water"
  geometry_fieldname = "way"
  geometry_type = "Polygon"
  sql = """
  SELECT
      ST_AsBinary(ST_SimplifyPreserveTopology(way, pixel_size(!ZOOM!)*.25)) AS way,
      NULL AS osm_id
    FROM ocean_polygons
    WHERE way && !BBOX!
  UNION ALL
  SELECT
      ST_AsBinary(ST_SimplifyPreserveTopology(way, pixel_size(!ZOOM!)*.25)) AS way,
      osm_id
    FROM planet_osm_polygon
    WHERE way && !BBOX!
      AND (waterway = 'riverbank'
        OR landuse = 'reservoir'
        OR "natural" = 'water')
      AND way_area > pixel_area(!ZOOM!)*0.25
  """

[[providers.layers]]
  name = "landcover"
  geometry_fieldname = "way"
  geometry_type = "Polygon"
  sql = """
  SELECT
      ST_AsBinary(ST_SimplifyPreserveTopology(way, pixel_size(!ZOOM!)*.25)) AS way,
      osm_id,
      landuse,
      "natural",
      leisure
    FROM planet_osm_polygon
    WHERE way && !BBOX!
      AND (landuse IN ('industrial', 'residential', 'forest', 'grass')
        OR "natural" IN ('wood')
        OR leisure IN ('pitch', 'common', 'park', 'golf_course', 'cemetery'))
      AND way_area > pixel_area(!ZOOM!)*0.25
  """

[[providers.layers]]
  name = "parks"
  geometry_fieldname = "way"
  geometry_type = "Polygon"
  sql = """
  SELECT
      ST_AsBinary(ST_SimplifyPreserveTopology(way, pixel_size(!ZOOM!)*.25)) AS way,
      osm_id,
      leisure
    FROM planet_osm_polygon
    WHERE way && !BBOX!
      AND leisure = 'nature_reserve'
      AND way_area > pixel_area(!ZOOM!)*0.25
  """

[[providers.layers]]
  name = "ne_boundaries"
  geometry_fieldname = "way"
  geometry_type = "LineString"
  sql = """
  SELECT
      ST_AsBinary(ST_RemoveRepeatedPoints(way,pixel_size(!ZOOM!)*0.25)) AS way,
      2 AS admin_level
    FROM ne_populated_places
    WHERE way && !BBOX!
  """

[[providers.layers]]
  name = "lz_boundaries"
  geometry_fieldname = "way"
  geometry_type = "LineString"
  # The SQL for boundaries is fairly complex because it deduplicates overlapping
  # lines, To do this, the boundary linestrings need to be turned into two-point
  # segments, distinct segments found, and then the result rebuilt into longer
  # linestrings. Tegola #559 prevents the use of CTEs, so this needs to be done
  # with nested subselects which are messier.
  # References:
  # - http://blog.cleverelephant.ca/2015/02/breaking-linestring-into-segments.html
  sql = """
  SELECT
      ST_AsBinary(ST_RemoveRepeatedPoints(
        (ST_Dump(ST_LineMerge(ST_Collect(way)))).geom,
        pixel_size(!ZOOM!)*0.25)) AS way,
      admin_level,
      osm_id
    FROM
    (SELECT
        DISTINCT ON (way) -- Select only one of the overlapping geoms
        way,
        admin_level,
        osm_id
      FROM
      (SELECT
          ST_MakeLine(
            lag((pt).geom) OVER (PARTITION BY ctid ORDER BY ctid, (pt).path),
            (pt).geom) AS way, -- This makes a line between the previous point and the next one
          admin_level,
          osm_id
        FROM
        (SELECT
            ctid,
            ST_DumpPoints(way) AS pt,
            admin_level,
            osm_id
          FROM
          (SELECT -- The innermost select just gets the admin boundaries
              ctid, -- ctid is kept around as a unique id because osm_id is not unique with long line splitting
              way,
              admin_level::integer,
              osm_id
            FROM planet_osm_roads
            WHERE way && !BBOX!
              AND boundary = 'administrative'
              AND admin_level IN ('0', '1', '2', '3', '4')
              AND osm_id < 0
          ) boundaries
        ) AS dumps
      ) AS segments
      WHERE way IS NOT NULL
      ORDER BY
        way,
        admin_level,
        osm_id
    ) AS deduplicated_segments
    GROUP BY
      osm_id,
      admin_level
  """

[[providers.layers]]
  name = "boundaries"
  geometry_fieldname = "way"
  geometry_type = "LineString"
  # This query is the same as the lz_boundaries layer, except it selects from
  # planet_osm_line and different admin_levels
  sql = """
  SELECT
      ST_AsBinary(ST_RemoveRepeatedPoints(
        (ST_Dump(ST_LineMerge(ST_Collect(way)))).geom,
        pixel_size(!ZOOM!)*0.25)) AS way,
      admin_level,
      osm_id
    FROM
    (SELECT
        DISTINCT ON (way) -- Select only one of the overlapping geoms
        way,
        admin_level,
        osm_id
      FROM
      (SELECT
          ST_MakeLine(
            lag((pt).geom) OVER (PARTITION BY ctid ORDER BY ctid, (pt).path),
            (pt).geom) AS way, -- This makes a line between the previous point and the next one
          admin_level,
          osm_id
        FROM
        (SELECT
            ctid,
            ST_DumpPoints(way) AS pt,
            admin_level,
            osm_id
          FROM
          (SELECT -- The innermost select just gets the admin boundaries
              ctid, -- ctid is kept around as a unique id because osm_id is not unique with long line splitting
              way,
              admin_level::integer,
              osm_id
            FROM planet_osm_line
            WHERE way && !BBOX!
              AND boundary = 'administrative'
              AND (admin_level IN ('0', '1', '2', '3', '4', '5', '6')
                OR admin_level IN ('7', '8') AND !ZOOM! >= 10)
              AND osm_id < 0
          ) boundaries
        ) AS dumps
      ) AS segments
      WHERE way IS NOT NULL
      ORDER BY
        way,
        admin_level,
        osm_id
    ) AS deduplicated_segments
    GROUP BY
      osm_id,
      admin_level
  """

[[providers.layers]]
  name = "buildings"
  geometry_fieldname = "way"
  geometry_type = "Polygon"
  sql = """
  SELECT
      ST_AsBinary(way) AS way,
      osm_id
    FROM planet_osm_polygon
    WHERE way && !BBOX!
      AND building IS NOT NULL
      AND building != 'no'
      AND way_area > pixel_area(!ZOOM!)*0.25
"""

[[maps]]
  name = "spirit"

[[maps.layers]]
  name = "water"
  provider_layer = "osm2pgsql.ne_water"
  min_zoom = 0
  max_zoom = 5
[[maps.layers]]
  name = "water"
  provider_layer = "osm2pgsql.lz_water"
  min_zoom = 6
  max_zoom = 9
  dont_simplify = true
[[maps.layers]]
  name = "water"
  provider_layer = "osm2pgsql.water"
  min_zoom = 10
  dont_simplify = true

[[maps.layers]]
  name = "landcover"
  provider_layer = "osm2pgsql.landcover"
  min_zoom = 6
  dont_simplify = true

[[maps.layers]]
  name = "parks"
  provider_layer = "osm2pgsql.parks"
  min_zoom = 6
  dont_simplify = true


[[maps.layers]]
  name = "boundaries"
  provider_layer = "osm2pgsql.ne_boundaries"
  min_zoom = 0
  max_zoom = 3
  dont_simplify = true
[[maps.layers]]
  name = "boundaries"
  provider_layer = "osm2pgsql.lz_boundaries"
  min_zoom = 4
  max_zoom = 7
  dont_simplify = true
[[maps.layers]]
  name = "boundaries"
  provider_layer = "osm2pgsql.boundaries"
  min_zoom = 8
  dont_simplify = true

[[maps.layers]]
  name = "buildings"
  provider_layer = "osm2pgsql.buildings"
  min_zoom = 12
  dont_simplify = true
